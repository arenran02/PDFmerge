<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë¡œì»¬ PDF íˆ´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- pdf-lib (ì´ë¯¸ì§€ â†’ PDF, PDF ë³‘í•©ìš©) -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <style>
    /* ê¸°ì¡´ ìŠ¤íƒ€ì¼ */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f4f4f5;
      color: #111827;
      display: flex;
      justify-content: center;
      padding: 32px 16px;
    }
    .app {
      width: 100%;
      max-width: 900px;
      background: #ffffff;
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.15);
      padding: 24px;
    }
    h1 {
      margin-top: 0;
      font-size: 24px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .mode-switch {
      display: flex;
      gap: 8px;
      margin: 16px 0 20px;
    }
    .mode-option {
      flex: 1;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.15s, border-color 0.15s, color 0.15s, transform 0.05s ease-out;
    }
    .mode-option input { display: none; }
    .mode-option.active {
      background: #111827;
      color: #f9fafb;
      border-color: #111827;
      transform: translateY(-1px);
    }
    .drop-zone {
      border-radius: 16px;
      border: 1.8px dashed #d1d5db;
      padding: 24px;
      text-align: center;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s, transform 0.05s ease-out;
    }
    /* í¸ì§‘ ê¸°ëŠ¥ ì¶”ê°€ ìŠ¤íƒ€ì¼ */
    .editor-container {
      margin-top: 20px;
    }
    .editor-btn {
      padding: 10px;
      background: #111827;
      color: #f9fafb;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      gap: 6px;
    }
    .browse-btn span { font-size: 14px; }
    #file-input { display: none; }

    .list-container { margin-top: 20px; }
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      color: #6b7280;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .list-header-left {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* ì •ë ¬ UI */
    .sort-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 999px;
      cursor: pointer;
      margin-right: 10px;
    }
    .editor-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .pdf-container {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      overflow: hidden;
    }
    .pdf-canvas {
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>
      <span class="logo">P</span>
      ë¡œì»¬ PDF ë„êµ¬
    </h1>

    <div class="mode-switch" id="mode-switch">
      <label class="mode-option active" data-mode="images">
        <input type="radio" name="mode" value="images" checked />
        <span>ì´ë¯¸ì§€ â†’ PDF</span>
      </label>
      <label class="mode-option" data-mode="merge">
        <input type="radio" name="mode" value="merge" />
        <span>PDF í•©ì¹˜ê¸°</span>
      </label>
      <label class="mode-option" data-mode="edit">
        <input type="radio" name="mode" value="edit" />
        <span>PDF í¸ì§‘</span>
      </label>
    </div>

    <div class="hint" id="mode-hint">
      PNG / JPG ì—¬ëŸ¬ ê°œë¥¼ ì˜¬ë ¤ì„œ í•˜ë‚˜ì˜ PDFë¡œ ë§Œë“¤ ìˆ˜ ìˆì–´ìš”.
    </div>

    <!-- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ -->
    <div class="drop-zone" id="drop-zone">
      <div class="drop-title" id="drop-title">
        ì—¬ê¸°ì— íŒŒì¼ì„ ë“œë˜ê·¸í•´ì„œ ì˜¬ë ¤ì£¼ì„¸ìš”
      </div>
      <div class="drop-sub" id="drop-sub">
        ë˜ëŠ”
      </div>
      <button class="browse-btn" id="browse-btn" type="button">
        <span>ğŸ“</span> íŒŒì¼ ì„ íƒí•˜ê¸°
      </button>
      <input type="file" id="file-input" multiple />
    </div>

    <!-- íŒŒì¼ ë¦¬ìŠ¤íŠ¸ -->
    <div class="list-container">
      <div class="list-header">
        <div class="list-header-left">
          <span>íŒŒì¼ ëª©ë¡ (ë“œë˜ê·¸í•´ì„œ ìˆœì„œ ë³€ê²½ ê°€ëŠ¥)</span>

          <!-- ì •ë ¬ ì˜µì…˜ -->
          <div class="sort-wrap" title="ì •ë ¬ ì ìš© í›„ ë“œë˜ê·¸í•˜ë©´ ìˆ˜ë™ìœ¼ë¡œ ì „í™˜ë©ë‹ˆë‹¤.">
            <span class="sort-label">ì •ë ¬</span>
            <select class="sort-select" id="sort-select">
              <option value="manual" selected>ìˆ˜ë™(ë“œë˜ê·¸)</option>
              <option value="name-asc">ì´ë¦„ìˆœ (Aâ†’Z)</option>
              <option value="name-desc">ì´ë¦„ìˆœ (Zâ†’A)</option>
              <option value="time-asc">ì‹œê°„ìˆœ (ì˜¤ë˜ëœâ†’ìµœì‹ )</option>
              <option value="time-desc">ì‹œê°„ìˆœ (ìµœì‹ â†’ì˜¤ë˜ëœ)</option>
            </select>
          </div>
        </div>

        <button class="clear-btn" id="clear-btn" type="button">ì „ì²´ ì§€ìš°ê¸°</button>
      </div>

      <ul class="file-list" id="file-list"></ul>
    </div>

    <div class="pdf-container" id="pdf-container" style="display: none;">
      <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
    </div>
  </div>

  <script>
    const dropZone = document.getElementById("drop-zone");
    const fileInput = document.getElementById("file-input");
    const modeSwitch = document.getElementById("mode-switch");
    const modeHint = document.getElementById("mode-hint");
    const browseBtn = document.getElementById("browse-btn");
    const dropTitle = document.getElementById("drop-title");
    const dropSub = document.getElementById("drop-sub");

    // ì •ë ¬
    const sortSelect = document.getElementById("sort-select");
    let sortOption = "manual";

    let mode = "images"; // "images" or "merge"
    let fileItems = [];
    let dragSrcIndex = null;

    function setSortOption(next) {
      sortOption = next;
      sortSelect.value = next;
    }

    function applySort(option) {
      if (option === "manual") return;

      if (option === "name-asc") {
        fileItems.sort((a, b) =>
          a.file.name.localeCompare(b.file.name, "ko", { numeric: true, sensitivity: "base" })
        );
      } else if (option === "name-desc") {
        fileItems.sort((a, b) =>
          b.file.name.localeCompare(a.file.name, "ko", { numeric: true, sensitivity: "base" })
        );
      } else if (option === "time-asc") {
        fileItems.sort((a, b) => a.addedAt - b.addedAt);
      } else if (option === "time-desc") {
        fileItems.sort((a, b) => b.addedAt - a.addedAt);
      }
    }

    sortSelect.addEventListener("change", (e) => {
      const val = e.target.value;
      setSortOption(val);
      applySort(val);
      renderFileList();
    });

    function updateModeUI() {
      const options = modeSwitch.querySelectorAll(".mode-option");
      options.forEach((opt) => {
        if (opt.dataset.mode === mode) opt.classList.add("active");
        else opt.classList.remove("active");
      });

      if (mode === "edit") {
        editorContainer.style.display = "block";
      } else {
        editorContainer.style.display = "none";
      }

      fileItems = [];
      setSortOption("manual");
      renderFileList();
    }

    modeSwitch.addEventListener("click", (e) => {
      const label = e.target.closest(".mode-option");
      if (!label) return;
      const newMode = label.dataset.mode;
      if (newMode && newMode !== mode) {
        mode = newMode;
        updateModeUI();
      }
    });

    fileInput.addEventListener("change", (e) => {
      if (!e.target.files) return;
      handleFiles(e.target.files);
      fileInput.value = "";
    });

    dropZone.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      if (!dt || !dt.files) return;
      handleFiles(dt.files);
    });

    function handleFiles(fileList) {
      const file = fileList[0]; // ì²« ë²ˆì§¸ íŒŒì¼ë§Œ ì²˜ë¦¬
      if (file.type === "application/pdf") {
        loadPdf(file);
      } else {
        alert("PDF íŒŒì¼ë§Œ ì§€ì›ë©ë‹ˆë‹¤.");
      }

      const now = Date.now();
      filtered.forEach((file, idx) => {
        fileItems.push({
          id: now.toString() + "-" + idx.toString() + "-" + Math.random().toString(16).slice(2),
          file,
          addedAt: now + idx,
        });
      });

      renderFileList();
    }

    function loadPdf(file) {
      const reader = new FileReader();
      reader.onload = async (e) => {
        const pdfData = new Uint8Array(e.target.result);
        pdfDoc = await pdfjsLib.getDocument(pdfData).promise;
        totalPages = pdfDoc.numPages;
        currentPage = 1;
        renderPdfPage(currentPage);
      };
      reader.readAsArrayBuffer(file);
    }

    function renderPdfPage(pageNum) {
      pdfDoc.getPage(pageNum).then((page) => {
        const viewport = page.getViewport({ scale: 1.5 });
        pdfCanvas.height = viewport.height;
        pdfCanvas.width = viewport.width;

        const context = pdfCanvas.getContext("2d");
        const renderContext = {
          canvasContext: context,
          viewport: viewport
        };
        page.render(renderContext);

        const thumb = document.createElement("div");
        thumb.className = "file-thumb";

        if (mode === "images") {
          const img = document.createElement("img");
          const reader = new FileReader();
          reader.onload = (e) => { img.src = e.target.result; };
          reader.readAsDataURL(item.file);
          thumb.appendChild(img);
        } else {
          thumb.textContent = "ğŸ“„";
        }

        const meta = document.createElement("div");
        meta.className = "file-meta";

        const name = document.createElement("div");
        name.className = "file-name";
        name.textContent = item.file.name;

        const size = document.createElement("div");
        size.className = "file-size";
        size.textContent = formatBytes(item.file.size);

        meta.appendChild(name);
        meta.appendChild(size);

        const removeBtn = document.createElement("button");
        removeBtn.className = "remove-btn";
        removeBtn.type = "button";
        removeBtn.textContent = "âœ•";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          fileItems.splice(index, 1);
          renderFileList();
        });

        li.appendChild(handle);
        li.appendChild(thumb);
        li.appendChild(meta);
        li.appendChild(removeBtn);

        li.addEventListener("dragstart", (e) => {
          if (sortOption !== "manual") setSortOption("manual");
          dragSrcIndex = Number(li.dataset.index);
          li.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
        });

        li.addEventListener("dragend", () => {
          li.classList.remove("dragging");
        });

        li.addEventListener("dragover", (e) => {
          e.preventDefault();
          const targetIndex = Number(li.dataset.index);
          if (targetIndex === dragSrcIndex || dragSrcIndex === null) return;
          moveItem(dragSrcIndex, targetIndex);
          dragSrcIndex = targetIndex;
          renderFileList();
        });

        fileListEl.appendChild(li);
      });
    }

    deleteBtn.addEventListener("click", () => {
      if (pdfDoc) {
        // í˜ì´ì§€ ì‚­ì œ ì²˜ë¦¬
        alert("í˜ì´ì§€ ì‚­ì œ ê¸°ëŠ¥ì€ PDF-libë¥¼ í™œìš©í•˜ì—¬ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    });

    insertBtn.addEventListener("click", () => {
      if (pdfDoc) {
        // í˜ì´ì§€ ì‚½ì… ì²˜ë¦¬
        alert("í˜ì´ì§€ ì‚½ì… ê¸°ëŠ¥ì€ PDF-libë¥¼ í™œìš©í•˜ì—¬ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      }
    });

    // âœ… EXIF íšŒì „ ë°©ì§€: íŒŒì¼ â†’ (ì˜¬ë°”ë¥¸ ë°©í–¥ìœ¼ë¡œ ë””ì½”ë”©) â†’ ìº”ë²„ìŠ¤ ì¬ì¸ì½”ë”©(ë©”íƒ€ ì œê±°) â†’ PDFì— ì‚½ì…
    async function normalizeImageForPdf(file) {
      // 1) EXIF ë°©í–¥ ë°˜ì˜í•´ì„œ ë¹„íŠ¸ë§µ ìƒì„± (ì§€ì› ì•ˆë˜ë©´ ê·¸ëƒ¥ ìƒì„±)
      let bitmap;
      try {
        bitmap = await createImageBitmap(file, { imageOrientation: "from-image" });
      } catch (e) {
        bitmap = await createImageBitmap(file);
      }

      // 2) ìº”ë²„ìŠ¤ì— ë‹¤ì‹œ ê·¸ë ¤ì„œ ë©”íƒ€ë°ì´í„°(Orientation) ì œê±°
      const canvas = document.createElement("canvas");
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;
      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.drawImage(bitmap, 0, 0);

      // 3) ë‹¤ì‹œ Blobìœ¼ë¡œ (JPEGëŠ” jpegë¡œ, PNGëŠ” pngë¡œ)
      const outMime = (file.type === "image/png") ? "image/png" : "image/jpeg";
      const blob = await new Promise((resolve) => {
        if (outMime === "image/jpeg") {
          canvas.toBlob(resolve, outMime, 0.92);
        } else {
          canvas.toBlob(resolve, outMime);
        }
      });

      // cleanup
      if (bitmap && bitmap.close) bitmap.close();

      if (!blob) {
        // ê·¹ë‹¨ì  ì˜ˆì™¸: toBlob ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì‚¬ìš©
        return { arrayBuffer: await file.arrayBuffer(), mime: file.type };
      }

      return { arrayBuffer: await blob.arrayBuffer(), mime: outMime };
    }

    async function createPdfFromImages() {
      const { PDFDocument } = PDFLib;
      const pdfDoc = await PDFDocument.create();

      for (const item of fileItems) {
        const file = item.file;

        // âœ… íšŒì „ ë°©ì§€ ì ìš©ëœ ì´ë¯¸ì§€ ë°”ì´íŠ¸
        const normalized = await normalizeImageForPdf(file);

        let image;
        if (normalized.mime === "image/png") {
          image = await pdfDoc.embedPng(normalized.arrayBuffer);
        } else {
          image = await pdfDoc.embedJpg(normalized.arrayBuffer);
        }

        const imgDims = image.scale(1);

        // ê¸°ë³¸ í˜ì´ì§€(ê¸°ë³¸ê°’) ìœ„ì— ì´ë¯¸ì§€ ë§ì¶° ë„£ê¸°
        const page = pdfDoc.addPage();
        const pageWidth = page.getWidth();
        const pageHeight = page.getHeight();

        const scale = Math.min(
          pageWidth / imgDims.width,
          pageHeight / imgDims.height
        );

        const imgWidth = imgDims.width * scale;
        const imgHeight = imgDims.height * scale;

        page.drawImage(image, {
          x: (pageWidth - imgWidth) / 2,
          y: (pageHeight - imgHeight) / 2,
          width: imgWidth,
          height: imgHeight,
        });
      }

      const pdfBytes = await pdfDoc.save();
      downloadPdf(pdfBytes, "images-to-pdf.pdf");
    }

    async function mergePdfs() {
      const { PDFDocument } = PDFLib;
      const mergedPdf = await PDFDocument.create();

      for (const item of fileItems) {
        const bytes = await item.file.arrayBuffer();
        const pdf = await PDFDocument.load(bytes);
        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
        copiedPages.forEach((p) => mergedPdf.addPage(p));
      }

      const pdfBytes = await mergedPdf.save();
      downloadPdf(pdfBytes, "merged.pdf");
    }

    function downloadPdf(pdfBytes, filename) {
      const blob = new Blob([pdfBytes], { type: "application/pdf" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    updateModeUI();
  </script>
</body>
</html>
